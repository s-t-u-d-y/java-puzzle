# 표현식 퍼즐

## 1. 홀수 확인

```java
return i % 2 == 1;
```

100%로 홀수를 구할 것 같지만 그렇지 않음.

음수가 들어간 경우 false를 리턴함.

이유는 자바의 % 연산자 정의 때문임.

`%`를 풀면 `(a / b) * b + (a % b) == a` 그리고 추가로 자바에서 정수를 나누면 버림을 수행하기 때문임.

그럼으로 홀수를 구하기 위해서는 더 쉽게

```java
return i % 2 != 0;
```

로 구현하면 홀수를 확인할 수 있음.

더 빠른 성능을 원하는 경우 비트 AND 연산자를 사용해 

다음과 같이 구현하면 된다.

```java
return (i & 1) != 0;
```

## 2. 변화를 위한 시간

```java
2.00 - 1.10 = ??
```

다음과 같은 값에 0.9를 기대하면 안된다.

자바는 double 정확하게 표현할 수 없어서 근접한 double로 표현한다.

또한 float도 정확한 연산을 할 수 없기에 금융 계산에서는 사용하면 안 된다.

정확한 십진 연산을 위해서는 BigDecimal을 사용할 수 있도록 하자.

단 BigDecimal(double)과 같은 생성자는 사용하면 안 되고 BigDecimal(String)과 같은 생성자를 사용해야 한다.

이유는 위와 비슷함.

기본 자료형 보다는 느리지만 잘 사용하자.

## 3. Long 자료형 나눗셈

```java
final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
(MICROS_PER_DAY / MILLIS_PER_DAY) == ??
```

결과가 1000 같지만 그렇지 않음.

결과는 5가 나오는데 위에 정의된 long 변수에 정수들이 long 타입이 아닌 int 타입으로 계산이 되면서 오버플로가 발생한다.

`오버플로란 ? `
```text
자바 오버플로(Java overflow)는 자바 프로그래밍 언어에서 발생할 수 있는 현상 중 하나로, 
정수 변수가 표현할 수 있는 범위를 넘어설 때 발생하는 오류를 말합니다. 
이러한 오류는 주로 정수형 변수가 자신이 표현할 수 있는 최대값을 넘어서면서 발생하게 됩니다.

자바에서 정수형 데이터 타입은 크게 4가지가 있습니다.

byte: 8비트
short: 16비트
int: 32비트
long: 64비트
예를 들어, int 타입 변수의 경우 약 -2,147,483,648부터 2,147,483,647까지의 범위를 표현할 수 있습니다. 
따라서 이 범위를 넘어서는 값을 변수에 할당하면 오버플로가 발생하게 됩니다.

오버플로가 발생하는 경우 변수에 할당하려는 값이 해당 데이터 타입의 표현 범위를 초과하게 되므로 
결과적으로 예상과 다른 값이 저장되거나 예외가 발생할 수 있습니다. 

이러한 상황에서 프로그래머는 값의 범위를 확인하고 적절한 대응을 취해야 합니다. 
일반적으로 오버플로를 방지하기 위해서는 적절한 데이터 타입을 선택하고, 범위를 체크하는 방어적인 프로그래밍을 해야합니다.
```

오버플로가 발생된 이유는 정의된 숫자들이 모두 int 자료형이기 때문임.

변수를 long으로 선언해도 int 끼리 계산된 이유는 자바는 타깃 타이핑을 지원하지 않아 long 연산을 하지 않음.

해결 방법은 첫번째 숫자를 long 자료형으로 만들어주면 된다.

그럼 다른 값들은 자연스레 long 연산이 진행 된다.

```java
final long MICROS_PER_DAY = 24L * 60 * 60 * 1000 * 1000;
final long MILLIS_PER_DAY = 24L * 60 * 60 * 1000;
(MICROS_PER_DAY / MILLIS_PER_DAY) == 1000
```
