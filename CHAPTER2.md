# 표현식 퍼즐

## 1. 홀수 확인

```java
return i % 2 == 1;
```

100%로 홀수를 구할 것 같지만 그렇지 않음.

음수가 들어간 경우 false를 리턴함.

이유는 자바의 % 연산자 정의 때문임.

`%`를 풀면 `(a / b) * b + (a % b) == a` 그리고 추가로 자바에서 정수를 나누면 버림을 수행하기 때문임.

그럼으로 홀수를 구하기 위해서는 더 쉽게

```java
return i % 2 != 0;
```

로 구현하면 홀수를 확인할 수 있음.

더 빠른 성능을 원하는 경우 비트 AND 연산자를 사용해 

다음과 같이 구현하면 된다.

```java
return (i & 1) != 0;
```

## 2. 변화를 위한 시간

```java
2.00 - 1.10 = ??
```

다음과 같은 값에 0.9를 기대하면 안된다.

자바는 double 정확하게 표현할 수 없어서 근접한 double로 표현한다.

또한 float도 정확한 연산을 할 수 없기에 금융 계산에서는 사용하면 안 된다.

정확한 십진 연산을 위해서는 BigDecimal을 사용할 수 있도록 하자.

단 BigDecimal(double)과 같은 생성자는 사용하면 안 되고 BigDecimal(String)과 같은 생성자를 사용해야 한다.

이유는 위와 비슷함.

기본 자료형 보다는 느리지만 잘 사용하자.

## 3. Long 자료형 나눗셈

```java
final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
(MICROS_PER_DAY / MILLIS_PER_DAY) == ??
```

결과가 1000 같지만 그렇지 않음.

결과는 5가 나오는데 위에 정의된 long 변수에 정수들이 long 타입이 아닌 int 타입으로 계산이 되면서 오버플로가 발생한다.

`오버플로란 ? `
```text
자바 오버플로(Java overflow)는 자바 프로그래밍 언어에서 발생할 수 있는 현상 중 하나로, 
정수 변수가 표현할 수 있는 범위를 넘어설 때 발생하는 오류를 말합니다. 
이러한 오류는 주로 정수형 변수가 자신이 표현할 수 있는 최대값을 넘어서면서 발생하게 됩니다.

자바에서 정수형 데이터 타입은 크게 4가지가 있습니다.

byte: 8비트
short: 16비트
int: 32비트
long: 64비트
예를 들어, int 타입 변수의 경우 약 -2,147,483,648부터 2,147,483,647까지의 범위를 표현할 수 있습니다. 
따라서 이 범위를 넘어서는 값을 변수에 할당하면 오버플로가 발생하게 됩니다.

오버플로가 발생하는 경우 변수에 할당하려는 값이 해당 데이터 타입의 표현 범위를 초과하게 되므로 
결과적으로 예상과 다른 값이 저장되거나 예외가 발생할 수 있습니다. 

이러한 상황에서 프로그래머는 값의 범위를 확인하고 적절한 대응을 취해야 합니다. 
일반적으로 오버플로를 방지하기 위해서는 적절한 데이터 타입을 선택하고, 범위를 체크하는 방어적인 프로그래밍을 해야합니다.
```

오버플로가 발생된 이유는 정의된 숫자들이 모두 int 자료형이기 때문임.

변수를 long으로 선언해도 int 끼리 계산된 이유는 자바는 타깃 타이핑을 지원하지 않아 long 연산을 하지 않음.

해결 방법은 첫번째 숫자를 long 자료형으로 만들어주면 된다.

그럼 다른 값들은 자연스레 long 연산이 진행 된다.

```java
final long MICROS_PER_DAY = 24L * 60 * 60 * 1000 * 1000;
final long MILLIS_PER_DAY = 24L * 60 * 60 * 1000;
(MICROS_PER_DAY / MILLIS_PER_DAY) == 1000
```
## 4. 초등학교 수준의 문제

```java
System.out.println(12345 + 5432l) == ??
```
답이 66666 같지만 아니다 17777이다.

5432l에 마지막이 1이 아니라 l이기 때문에 잘못 볼 수 있다.

그렇기 때문에 long 자료형을 사용할때는 소문자가아닌 대문자 `L`을 사용하도록 하자

## 5. 16진수의 즐거움

```java

```

## 6. 다중 자료형 변환

```java

```

## 7. 변수 교환

```
int x = 1984;
int y = 2001;

x ^= y ^= x ^= y

System.out.println("x = " + x + "; y = " + y);
```

x = 2001; y = 1984의 출력 값을 기대하면 틀렸다.

출력 값은 x = 0; y = 1984이다

이유는 자바는 x ^= expr 형태의 표현식을 계산할 때, x는 expr이 계산되기 전에 추출 되고 expr이 게산된 이후에 합쳐진다.

그래서 제일 상단의 코드에서는 x가 두 번 추출되지만 할당이 일어나기 전에 추출된다.

위의 `x ^= y ^= x ^= y`를 자바에서 연산되는 걸보면
```java

int tmp1 = x;
int tmp2 = y;
int tmp3 = x ^ y;

x = tmp3;
y = tmp2 ^ tmp3;
x = tmp1 ^ y;
```
위의 연산을 진행하기 때문이다.

그렇기 때문에 일반적인 코드는

```java
int temp = x;
x = y;
y = temp;
```

이 처럼 작성한다.

정리하자면

`하나의 표현식에 동일한 변수를 여러 번 할당하지 마세요`

`뭔가 이상하고 특별한 기교를 부리려고 하지 마세요`

## 8. Dos Equis

```java
char x = 'X';
int i = 0;
System.out.print(true ? x : 0);
System.out.print(false? i : x);
```
어떤 값이 나올거 같은가?

"XX"를 기대했다면 뒤통수 맞는다 "X88"이 나오게 된다.

`여러 자료형을 혼합해서 계산하면 복잡합니다. 이번 퍼즐도 그런 문제입니다.`

조건 연산자의 최종 자료형을 결정하는 규칙은 엄청나게 많다.

그 중 중요한 3가지를 정리해 보면 다음과 같다.
1. 두 번째와 세 번째 피연산자의 자료형이 같다면 해당 자료형으로 결과를 냅니다. 이런 경우에는 아무 문제가 없습니다.
2. byte, short, char 자료형을 T자료형이라고 합시다. 피연산자 중 하나가 T 자료형이고 다른 하나가 T 자료형으로 변환 가능한 int 상수라면 T 자료형으로 결과를 냅니다.
3. 만약 이것이 아니라면 '이항 숫자 확산(binary numeric promotion)'을 적용합니다. 그리고 두 번째, 세 번째 피연산자 중 큰 자료형으로 결과를 냅니다.

위의 코드에서는 피연산자가 char와 int이기 때문에 2,3번이 적용되어 첫번쨰는 X 다음은 88이 적용된다.

한마디로 혼합 자료형 연산은 하지마라.

## 9. 같은 것 같으면서도 다른것(1)

```java
x += i;
x = x + i;
```
위의 코드에서 위와 아래의 코드가 같다고 생각하지만 사실 다르다.

위는 복합 할당 연산자를 사용하고 아래는 단순 할당 연사자를 사용한다

`복합 할당 연산자는 연산 결과를 왼쪽 변수의 자료형으로 자동 변환합니다.`

위의 글에서 알 수 있듯이 복합 할당 연산자는 자료형으로 변환하기 떄문에 같은 자료형의 경우 문제가 없지만 

단순 할당 연산자의 경우 자료형이 다를 경우 컴파일 시점에서 오류가 발생한다.

```java
short x = 0;
int i = 123456;

x += i; // 자동 자료형 변환이 일어난다.
```
위의 코드의 값이 123456이 될것같지만 실제로는 -7616이 나오게 된다.

int의 자료형이 너무커 short 자료형에 오버플로가 발생하기 때문이다.

그렇기 때문에 복합 할당 연산자는 위험하기에 `byte, short, char의 자료형을 사용할때는 복합 할당 연산자를 사용하지 말아야 한다.`

또한 int 자료형의 변수에 복합 할당 연산자를 적용할 때에도 long, float, double 자료형이 표현식에 오지 않게 해야한다.

정리하자면

`복합 할당 연산자는 자동 자료형 변환이 일어난다. 연산 결과가 변수가 감당할 수 없는 범위라면 축소 변환이 일어나서 숫자가 손실될 수 있다.`

## 10. 같은 것 같으면서도 다른것(2)

이번에는 반대로 코드를 작성해보자

```java
x = x + i;
x += i;
```
위의 코드와 비슷하지만 어떤 문장이 컴파일되어야 하는지가 다르기에 전혀 다른 문제이다.

복합 연산자가 단순 연산자보다 유연할거 같지만 단 한 간지에서 단순 연산자가 더 유연한 경우가 있다.

복합 연산자는 클래스 양쪽 피연산자 모두 int 자료형과 같은 기본 자료형이거나 Integer 클래스와 같은 박스 자료형이여야 한다.

하지만 한 가지 예외로 += 연산자의 왼쪽 피연산자가 String의 경우 오른쪽 피연산자로 모든 자료형이 올 수 있으며 이런 경우에는 문자열 연결을 수행한다.

단순 할당 연산자(+)는 왼쪽 피연산자가 객체 참조가 올 때 유연하게 작동한다.

오른쪽 표현식이 왼쪽 변수에 할당 호환된다면 원하는 대로 사용할 수 있다.

예로 다음과 같은 코드가 있을때 

```java
Object x = "Buy";
String i = "Effective Java!"
```
x + i 의 결과가 String 자료형 이기에 생성된 문자열을 Object 타입에 할당하므로 아무 문제가 없다.

하지만 복합 연산자는 왼쪽 피연산자가 String 자료형이 아닌 참조형이기에 오류가 발생한다.

```java
x += i;
```
